<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Io学习笔记一</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/index.html">blog</a></h1>
              <a class="extra" href="/about.html">about</a>
            </div>

            <h2>Io学习笔记一</h2>
<p class="meta">2012-12-27 23:42</p>

<div id="post">
<h2>创建1个对象</h2>

<pre><code>Io&gt; A := Object clone
</code></pre>

<p>:= 表示不存在则创建，存在则复制<br/>
= 不存在时赋值会报错<br/>
对象在前，空格，发送的消息，空格相当于是'.'<br/>
<code>Object clone</code> 在js里相当于 <code>Object.clone()</code></p>

<h2>给对象槽赋值</h2>

<pre><code>Io&gt; A say := "I'm saying, haha"
</code></pre>

<p>相当于js里的
<code>
A = {
  say: "I'm saying, haha"
};
</code>
获取槽里的值
<code>
Io&gt; A say
</code>
相当于js里的<code>A.say</code></p>

<h2>查看所有槽</h2>

<pre><code>Io&gt; A slotNames
==&gt; list(type, say)
</code></pre>

<p>相当于js的里的<code>Object.values(A)</code></p>

<h2>继承</h2>

<pre><code>Io&gt; A := Object clone
Io&gt; A say:= "say, haha"
Io&gt; Car := A clone
Io&gt; Car say
==&gt; say haha
</code></pre>

<p>car里没有say，它就直接把say消息直接转发给A
<code>
Io&gt; fa := Car clone
Io&gt; fa slotNames
==&gt; list()
Io&gt; fa type
==&gt; Car
</code>
io里约定大写字母开头的是类型，小写字母开头的也是对象，但不是类型<br/>
在io里，对象是槽的容器，发送槽名给槽可以获得该槽，如果该槽不存在，则调用父对象的槽。</p>

<h2>方法</h2>

<pre><code>method("a, haha" println)
</code></pre>

<p>创建一个方法，类似js里的
<code>
function() {
  console.log('a, haha');
}
</code>
<code>
Io&gt; method() type
==&gt; Block
</code>
方法的类型是Block
<code>
Io&gt; Car drive := method("Drive" println)
==&gt; method(
    "Drive" println
)
</code>
给Car添加一个方法 drive，相当于js里的
<code>
Car.drive = function() {
  console.log('Drive');
};
</code>
因为fa继承Car，所以fa可以直接调用drive
<code>
Io&gt; fa drive
Drive
==&gt; Drive
</code></p>

<h2>获取槽中的内容</h2>

<p>可以给对象发送getSlot来获取槽中的内容，无论是变量还是方法<br/>
如果该槽不存在，getSlot会提供父对象的槽
<code>
Io&gt; fa getSlot("drive")
==&gt; method(
    "Drive" println
)
IO&gt; fa getSlot("type")
==&gt; Car
</code></p>

<h2>获取对象的原型</h2>

<p>可以给对象发送proto获取对象的原型
<code>
Io&gt; fa proto
==&gt; Car_0x7f81f8caa5a0:
  drive = method(…)
  type = "Car"
Io&gt; Car proto
==&gt; A_0x7f81f8e70230:
  say = "say haha"
  type = "A"
</code></p>

<h2>主命名空间</h2>

<p>Lobby是主命名空间，包含了所有的已命名对象
<code>
Io&gt; Lobby
==&gt; Object_0x7f81f8c1ba20:
  A = A_0x7f81f8e70230
  Car = Car_0x7f81f8caa5a0
  Lobby = Object_0x7f81f8c1ba20
  Protos = Object_0x7f81f8c1ad00
  _ = Object_0x7f81f8c1ba20
  exit = method(…)
  fa = Car_0x7f81f8e83840
  forward = method(…)
  set_ = method(…)
</code>
你可以看到exit的实现，forward，Protos和我们自定义的东西
查看exit的实现
<code>
Io&gt; Lobby getSlot("exit")
==&gt; # [unlabeled]:0
method(
    CLI stop
)
</code>
Protos的实现
<code>
Io&gt; Lobby getSlot("Protos")
==&gt; Object_0x7f81f8c1ad00:
  Addons = Object_0x7f81f8c1be30
  Core = Object_0x7f81f8c1b9b0
</code></p>

<h2>基本准则</h2>

<ul>
<li>所有事物都是对象</li>
<li>所有与对象的交互都是消息</li>
<li>不需要实例化类，而是复制那些叫做原型的对象</li>
<li>对象会记住它的类型</li>
<li>对象有槽</li>
<li>槽包含对象(包括方法对象)</li>
<li>消息返回槽中的值，或调用槽中的方法</li>
<li>如果对象无法响应某消息，它会把该消息发送给自己的原型</li>
</ul>


<h1>列表和映射</h1>

<p>Io包含了几种类型的集合。列表(list) 是任意类型对象的有序集合，所有列表的原型都是List对象。
而Map对象是键值对的原型，成为映射，和ruby的散列表一样。</p>

<h2>创建列表</h2>

<pre><code>Io&gt; todos := list("eat", "sleep")
==&gt; list(eat, sleep)
Io&gt; todos size
==&gt; 2
Io&gt; todos append("talk")
==&gt; list(eat, sleep, talk)
</code></pre>

<p>Io在表示列表时有一种快捷方式，由Object对象提供的list方法。它能把传入方法的参数包装起来形成列表，使用list方法，我们可以这样创建列表:
<code>
Io&gt; Io&gt; list(1, 2, 3, 4)
==&gt; list(1, 2, 3, 3, 4)
</code>
对列表进行数学运算，或是当做其他数据类型(比如栈)，List对象也提供了各种简便方法:
<code>
Io&gt; list(1, 2, 3, 4) average
==&gt; 2.5
Io&gt; list(1, 2, 3, 4) sum
==&gt; 10
Io&gt; list(1, 2, 3, 4) at(1)
==&gt; 2
Io&gt; list(1, 2, 3, 4) append(4)
==&gt; list(1, 2, 3, 4, 4)
Io&gt; list(1, 2, 3, 4) pop
==&gt; 4
Io&gt; list(1, 2, 3, 4) prepend(0)
==&gt; list(0, 1, 2, 3, 4)
Io&gt; list() isEmpty
==&gt; true
</code>
另一种主要集合是Map对象，像是ruby的散列表，这个没有语法糖，必须用API操作:
<code>
Io&gt; p := Map clone
==&gt; Map_0x7f81f8e4d8d0:
Io&gt; p atPut("name", "zhangsan")
==&gt; Map_0x7f81f8e4d8d0:
Io&gt; p at("name")
==&gt; zhangsan
Io&gt; p atPut("style", "rock")
==&gt; Map_0x7f81f8e4d8d0:
Io&gt; p asObject
==&gt; Object_0x7f81f983e170:
  name = "zhangsan"
  style = "rock"
Io&gt; p asList
==&gt; list(list(name, zhangsan), list(style, rock))
Io&gt; p keys
==&gt; list(name, style)
Io&gt; p size
==&gt; 2
</code>
散列表和Io对象很像，散列表的键就是一个个绑定了值的槽。</p>

<h2>布尔值 true false nil 和单例</h2>

<pre><code>Io&gt; 4 &lt; 5
==&gt; true
Io&gt; 4 &lt;= 3
==&gt; false
Io&gt; true and false
==&gt; false
Io&gt; true and true
==&gt; true
Io&gt; true or true
==&gt; true
Io&gt; 4 &lt; 5 and 6 &lt; 7
==&gt; true
Io&gt; true and 6
==&gt; true
Io&gt; true and 0
==&gt; true
</code></pre>

<p>和ruby一样，0是true，而true又是什么呢
<code>
Io&gt; true pro to
==&gt; Object_0x7f81f8c04010:
                   = Object_()
  != = Object_!=()
  - = Object_-()
… 省略一堆
</code>
<code>
Io&gt; true clone
==&gt; true
Io&gt; false clone
==&gt; false
Io&gt; nil clone
==&gt; nil
</code>
true, false, nil都是单例，复制它们，返回的只是单例对象的值</p>

<h2>创建自己的单例对象</h2>

<pre><code>Io&gt; S := Object clone
==&gt; S_0x7f81f8ef0f40:
  type = "S"
Io&gt; S clone := S
==&gt; S_0x7f81f8ef0f40:
  clone = S_0x7f81f8ef0f40
  type = "S"
Io&gt; S clone
==&gt; S_0x7f81f8ef0f40:
  clone = S_0x7f81f8ef0f40
  type = "S"
Io&gt; s1 := S clone
==&gt; S_0x7f81f8ef0f40:
  clone = S_0x7f81f8ef0f40
  type = "S"
Io&gt; s2 := S clone
==&gt; S_0x7f81f8ef0f40:
  clone = S_0x7f81f8ef0f40
  type = "S"
Io&gt; s1 == s2
==&gt; true
</code></pre>

<p>我们重新定义了S 的clone方法，让它返回本身，这样就形成了一个单例</p>

<h2>小心</h2>

<p>Io里你几乎可以改变任何对象上的任何一个槽，比如这样
<code>
Io&gt; Object clone := "haha"
</code>
因为你覆盖了Object上的clone方法，从此你无法再创建对象了，只能终止进程重新开始。
当然这些自由在实现特定领域语言(DSL: domian-specific language)时非常方便。</p>

<h2>基础类型的方法</h2>

<pre><code>Io&gt; true slotNames
==&gt; list(asSimpleString, asString, not, ifFalse, else, ifTrue, or, type, justSerialized, clone, elseif, then)
Io&gt; Object slotNames
==&gt; list(slotSummary, ownsSlots, and, apropos, foreachSlot, performWithArgList, coroWith, &lt;, actorRun, removeAllSlots, for, isTrue, clone, become, !=, write, switch, setSlotWithType, method, ancestors, futureSend, resend, isActivatable, lazySlot, list, justSerialized, evalArg, uniqueId, @@, do, thisContext, deprecatedWarning, setProto, println, hasProto, writeln, setSlot, handleActorException, inlineMethod, ifNonNil, isKindOf, setIsActivatable, removeAllProtos, coroFor, pause, continue, ifNil, stopStatus, prependProto, ancestorWithSlot, print, protos, evalArgAndReturnSelf, doString, type, ?, return, break, &gt;, message, ==, currentCoro, slotNames, hasLocalSlot, while, perform, serialized, ifNonNilEval, wait, asString, returnIfNonNil, getLocalSlot, or, getSlot, asSimpleString, compare, coroDoLater, hasDirtySlot, slotDescriptionMap, removeProto, appendProto, in, isNil, uniqueHexId, loop, lexicalDo, not, .., doRelativeFile, try, launchFile, , yield, isError, ifNilEval, init, evalArgAndReturnNil, doFile, serializedSlotsWithNames, argIsActivationRecord, returnIfError, isIdenticalTo, super, isLaunchScript, serializedSlots, cloneWithoutInit, hasSlot, contextWithSlot, thisLocalContext, &gt;=, if, relativeDoFile, memorySize, &lt;=, asyncSend, thisMessage, @, markClean, coroDo, slotValues, -, doMessage, proto, ifError, newSlot, updateSlot, removeSlot, shallowCopy, block, actorProcessQueue, raiseIfError, setProtos, argIsCall)
Io&gt; List slotNames
==&gt; list(isEmpty, remove, exSlice, sortByKey, mapFromKey, ListCursor, map, atPut, uniqueCount, contains, itemCopy, copy, sortInPlace, removeAll, asMap, sort, sliceInPlace, insertBefore, rest, containsAny, asString, min, removeSeq, cursor, intersect, reverseForeach, foreach, empty, sortKey, fromEncodedList, with, removeAt, justSerialized, max, asJson, pop, size, selectInPlace, average, third, push, reduce, detect, insertAfter, at, appendIfAbsent, last, sum, select, difference, removeFirst, indexOf, groupBy, asMessage, reverse, union, slice, isNotEmpty, mapInPlace, append, preallocateToSize, reverseInPlace, asSimpleString, removeLast, flatten, sortInPlaceBy, prepend, asEncodedList, atInsert, appendSeq, insertAt, unique, reverseReduce, join, second, swapIndices, containsAll, first, sortBy, containsIdenticalTo, setSize, capacity)
Io&gt; Map slotNames
==&gt; list(map, at, atPut, asObject, reverseMap, merge, asList, detect, isNotEmpty, keys, removeAt, hasValue, isEmpty, mergeInPlace, select, hasKey, empty, foreach, with, justSerialized, asJson, atIfAbsentPut, addKeysAndValues, size, values)
</code></pre>

</div>


            <div class="footer">
              <div class="contact">
                <div>lyuehh</div>
                <div>programmer</div>
                <div>lyuehh^gmail.com</div>
              </div>
              <div class="contact">
                <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                <a href="http://weibo.com/lyused/">weibo.com/lyused</a><br />
              </div>
            </div>
          </div>

        </div> <!-- /container -->

    </body>
</html>
