<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>编程语言入门介绍之 - shell</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/index.html">blog</a></h1>
              <a class="extra" href="/about.html">about</a>
            </div>

            <h2>编程语言入门介绍之 - shell</h2>
<p class="meta">2013-03-18 17:33</p>

<div id="post">
<h2>1 简介</h2>

<p>维基百科介绍: <a href="https://en.wikipedia.org/wiki/Shell_script">https://en.wikipedia.org/wiki/Shell_script</a><br/>
shell是类Unix系统如<a href="http://zh.wikipedia.org/wiki/linux">Linux</a>, <a href="http://zh.wikipedia.org/wiki/Mac">MacOS</a>, <a href="http://zh.wikipedia.org/wiki/Freebsd">FreeBSD</a>中用户与内核进行交互操作的接口,
它接受用户输入的命令, 并把它送入内核执行.<br/>
常见的shell有<a href="http://zh.wikipedia.org/wiki/Bash">bash</a>, <a href="http://zh.wikipedia.org/wiki/Ksh">ksh</a>, <a href="http://zh.wikipedia.org/wiki/Zsh">zsh</a>等, 它们的语法大致类似, 有些许区别, 这里就不介绍了..
shell脚本语言是一种解释性语言, 没有像C语言那样的编译阶段,由shell直接解析后执行.</p>

<h2>2 语法</h2>

<h3>2.1 赋值</h3>

<pre><code>foo=3
</code></pre>

<p>注意不能写成<code>foo = 3</code>, 因为shell脚本里的每一行都是要在命令执行的, 所以<code>foo = 3</code>在shell看来,
它表示调用一个叫<code>foo</code>的程序, 并且传递给它了2个参数<code>=</code>和<code>3</code>, 系统里并没有一个叫<code>foo</code>的程序,
所以肯定会报错.  如果你执意要在<code>=</code>两边加上空格的话,可以这样写<code>(( foo = 3))</code>.  赋值后使用变量:
<code>
echo $foo
</code>
也就是调用变量的时候,要在变量前加上<code>$</code>.
可以把赋值和调用写在一行上,中间用<code>;</code>分割, 如果一行只有一个语句,可以省略<code>;</code>
<code>
foo=3;echo $foo
</code>
在字符串中引用变量:
<code>
bar=3
foo="bar is $bar";echo $foo
</code>
如果变量名后面会有其他字符,那么可以用<code>{}</code>把变量名引起来:
<code>
bar=3
foo="bar is ${bar}lalala~~~";echo $foo
</code>
一个变量可以包含多个值:
<code>
foo=(1 2 3);echo $foo
</code>
shell中的变量是无类型的, 默认变量均为字符型.</p>

<h3>2.2 三种引号</h3>

<p>看例子就明白了:
```</p>

<h1>双引号</h1>

<p>foo=3
echo "foo is $foo" # -> foo is 3
echo "pwd is <code>pwd</code>" # -> pwd is /Users/yourname
echo "foo\tis\t$foo" # -> foo   is  3</p>

<h1>单引号</h1>

<p>foo=3
echo 'foo is $foo' # -> foo is $foo
echo 'pwd is <code>pwd</code>' # -> pwd is <code>pwd</code>
echo 'foo\tis\t$foo' # -> foo   is  $foo
<code>``
1. 反引号</code>(就是键盘上1左边那个键)中的内容会被shell当做系统命令执行
2. 双引号会解释变量, 执行反引号里的命令, 也会解释转义字符
3. 单引号不会解释变量,也不会执行反引号内的命令,但是会解释转义字符</p>

<h3>2.3 运算符</h3>

<p>和大多其他编程语言类似:
<code>#</code>后面的内容表示注释.</p>

<pre><code>+ # $((3+5)) -&gt; 8
- # $((5-3)) -&gt; 2
* # $((3*5)) -&gt; 15
/ # $((5/3)) -&gt; 1
% # $((5%3)) -&gt; 2
</code></pre>

<p>复合赋值运算符:
<code>
+=
-=
*=
/=
%=
</code></p>

<p>位运算符:
```
&lt;&lt;</p>

<blockquote><blockquote><p>&amp;
!
~
^
```</p></blockquote></blockquote>

<p>自增自减:
```</p>

<h2>++</h2>

<pre><code>
### 2.4 测试结构
测试命令用于测试表达式的真假, 如果测试条件为真,返回一个0值;否则,返回一个非0值.
测试命令有2中,使用test命令`test expression`, 其中的`expression`可以为算数运算符,也可以是文件属性等;
另一种是方括号语法`[ expression ]`, 注意`[`之后和`]`之前的空格必不可少,因为`[`本身是一个命令, 后面的
都是这个命令的参数, 而`]`是它的最后一个参数.

#### 2.4.1 整数比较运算符
</code></pre>

<p>[ n1 -eq n2 ] # 相等比较,如果n1和n2相等,返回0
[ n1 -ge n2 ] # 大于或等于比较
[ n1 -gt n2 ] # 大于比较
[ n1 -le n2 ] # 小于或等于比较
[ n1 -lt n2 ] # 小于比较
[ n1 -ne n2 ] # 不相等比较
<code>
示例
</code>
[ 5 -eq 5 ]
echo $? # $?表示最后一条命令的执行结果
```</p>

<h4>2.4.2 浮点数比较</h4>

<p>shell默认只支持整数之间的计算和比较, 如果需要进行浮点数计算或比较,需要用到<code>bc</code>这个命令.
```</p>

<h1>比较两个浮点数</h1>

<p>echo "5.4 > 3.2" | bc # -> 1 # bc结果为1表示结果为真
echo "4.3 * 1.2 " | bc # -> 5.1
<code>``
更多的用法请查看</code>bc<code>的帮助手册,</code>man bc`.</p>

<h4>2.4.3 字符串比较</h4>

<pre><code>[ -n string ] #测试字符串string是否不为空
[ -z tring ]  #测试字符串string是否为空
[ str1 = str2 ] #测试str1是否与str2相同
[ str1 != str2 ] #测试str1是否域str2不相同
</code></pre>

<p>测试字符串时,建议使用双引号将字符串引起来.</p>

<h4>2.4.4 文件操作符</h4>

<pre><code>[ -d /etc/passwd ] #测试文件是否为目录
[ -e file ] # 测试文件是否存在
[ -f file ] # 测试文件是否为普通文件
[ -s file ] # 测试文件的长度是否不为0
[ -r file ] # 测试文件是否为进程可读文件
[ -w file ] # 测试文件是否为进程可写文件
[ -x file ] # 测试文件是否为进程可执行文件
[ -L file ] # 测试文件是否为符号链接
</code></pre>

<h4>2.4.5 逻辑运算符</h4>

<p>逻辑运算符用来测试多个条件是否为真或为假.
<code>
[ ! expression ] # 如果expression为真, 则测试结果为假
[ expre1 -a expre2 ] # 如果expre1和expr2同时为真, 则判断结果为真
[ expre1 -o expre2 ] # 如果expre1和expr2中有一个为真, 则结果为真
</code>
示例:
<code>
[ -e /etc/passwd -a -d /etc ] # -&gt; 0, 结果为真
</code></p>

<h3>2.5 控制结构</h3>

<h4>2.5.1 条件判断</h4>

<p>if语句:
```
if expression
then
  echo 'true'
fi</p>

<h1>then 语句可以和if语句写到一行上, 但是一定要加上分号</h1>

<p>if expression; then
  echo 'true'
fi</p>

<h1>else</h1>

<p>if expression; then
  echo 'true'
else
  echo 'false'
fi</p>

<h1>多个else</h1>

<p>if expression1; then
  echo 'expr1 true'
elif expression2; then
  echo 'expr2 true'
elif expression3; then
  echo 'expr3 true'
fi
```</p>

<h4>2.5.2 switch case</h4>

<p>和<code>if else</code>语句不同,switch case语句只能比较字符串常量或者正则表达式.
<code>
case var in
  start)
    echo 'start';
    ;;
  stop)
    echo 'stop';
    ;;
  restart)
    echo 'restart';
    ;;
  *)
    echo 'other';
    ;;
esca
</code></p>

<h4>2.5.3 循环</h4>

<p>for循环:
<code>
for var in (list)
do
  echo $var
done
</code>
示例:
```
for var in 1 2 3 4 5
do
  echo $var
done</p>

<h1>或者和其他命令一起使用</h1>

<p>for l in <code>ls</code>
do
  echo $l
done
<code>
类C风格的for循环:
</code>
for ((i = 1; i &lt;= 5; i++))
do
  echo $i
done
```</p>

<p>while循环:
```
i=1
while [ $i -le 5 ]
do
  echo $i
  i=$(( $i+1 ))
done</p>

<h1>也可以用另一种语法</h1>

<p>i=1
while (( $i &lt;= 5 ))
do
  echo $i
  i=$(( $i+1 ))
done
```</p>

<p>until循环:
until循环和while循环类似, 但是until是在判断条件为假时继续执行, 直到判断条件为真时停止循环.
```
i=1
util (( $i > 5 )) # -> 和while的条件刚好相反
do
  echo $i
  i=$(( $i+1 ))
done</p>

<h1>也可以用另一种语法</h1>

<p>i=1
util [ $i -gt 5 ]
do
  echo $i
  i=$(( $i+1 ))
done
```</p>

<h3>2.6 重定向 管道</h3>

<p>重定向用来向程序输入数据, 或者将一个命令的输出结果保存到一个文件.
```
cat &lt; until.sh # 将until.sh的内容传递给cat命令</p>

<h1>当然cat命令可以接受文件名作为参数, 你可以直接执行<code>cat until.sh</code></h1>

<p>ls > a.txt # 将ls命令的返回结果保存到a.txt这个文件, 如果a.txt不存在,则会创建,如果已经存在,则会覆盖里面的内容
ls -alg >> a.txt #将命令的结果追加到a.txt文件末尾
<code>
管道和重定向类似, 但是它是将一个命令的输出作为下一个命令的输入.
</code>
cd / # 切换到根目录
ls | grep var # 使用管道符,在ls命令的返回值里查找var这个字符串
```</p>

<h3>2.7 函数</h3>

<p>定义一个函数:
<code>
hello()
{
  echo "hello"
}
</code>
调用函数:
<code>
hello # -&gt; hello
</code>
向函数传递参数:
<code>
hello()
{
  echo "hello $1"
}
hello aaa # -&gt; hello aaa
</code>
给函数传递参数时, 参数之间用空格分割, $1表示第1个参数, $2表示第二个参数, 依此类推...
$#表示参数的个数</p>

<h2>end</h2>

<p>大概就是这些, 其他细节, 还有很多没有提到的, 请参考相关书籍或者手册...</p>

</div>


            <div class="footer">
              <div class="contact">
                <div>lyuehh</div>
                <div>programmer</div>
                <div>lyuehh^gmail.com</div>
              </div>
              <div class="contact">
                <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                <a href="http://weibo.com/lyused/">weibo.com/lyused</a><br />
              </div>
            </div>
          </div>

        </div> <!-- /container -->

    </body>
</html>
