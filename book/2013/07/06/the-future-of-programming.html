<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>读书笔记 - 代码的未来</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">
         <link type="text/css" rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.0.0/css/bootstrap-theme.min.css"/>
         <link type="text/css" rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.0.0/css/bootstrap.min.css"/>
    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/index.html">blog</a></h1>
              <a class="extra" href="/about.html">about</a>
            </div>

            <h2>读书笔记 - 代码的未来</h2>
<p class="meta">2013-07-06 17:13</p>

<div id="post">
<h1>1 编程的时间和空间</h1>

<h2>1.1 编程的本质</h2>

<ul>
<li>编程的本质是思考</li>
<li>编程可以体会到创造的乐趣</li>
<li>快速提高的性能改变了社会</li>
<li>摩尔定律的局限</li>
<li>社会化与编程</li>
</ul>


<h2>1.2 未来预测</h2>

<ul>
<li>极限</li>
<li>价格</li>
<li>性能</li>
<li>容量</li>
<li>带宽</li>
</ul>


<h1>2 编程语言的过去、现在和未来</h1>

<h2>2.1 编程语言的世界</h2>

<ul>
<li>打孔纸袋</li>
<li>机器语言</li>
<li>汇编语言</li>
</ul>


<h3>编程语言的历史</h3>

<ol>
<li>FORTRAN</li>
<li>COBOL</li>
<li>Lisp</li>
<li>SNOBOL</li>
<li>Prolog，Haskell</li>
<li>C，C++，Java，JavaScript，Ruby，Perl，Python，PHP</li>
</ol>


<h3>未来的编程语言</h3>

<ul>
<li>并行化</li>
<li><p>简洁</p></li>
<li><p>变化不大</p></li>
<li>不会再用编程语言来编程</li>
<li>更抽象的编程语言</li>
</ul>


<h2>2.2 DSL(特定领域语言)</h2>

<h3>外部DSL和内部DSL</h3>

<ul>
<li>外部DSL：由专用的语言引擎来实现的DSL，称为外部DSL，如XML，正则表达式，SQL，JSON等</li>
<li>内部DSL：在现有语言中实现DSL，如在Ruby，Lisp中实现DSL</li>
</ul>


<h3>DSL的优势</h3>

<ul>
<li>节约时间</li>
<li>简洁</li>
<li>提高效率</li>
<li>抽象</li>
</ul>


<h3>DSL设计的构成要素</h3>

<ul>
<li>上下文 Context</li>
<li>语句 Sentence</li>
<li>单位 Unit</li>
<li>词汇 Vocabulary</li>
<li>层次结构 Hierarchy</li>
</ul>


<h2>2.3 元编程</h2>

<h3>Meta，Reflection</h3>

<ul>
<li>meta，，元，表示对自身的描述</li>
<li>描述数据所具有的结构的数据，就是关于数据本身的数据，被称为元数据</li>
</ul>


<h3>数据和程序</h3>

<ul>
<li>Lisp</li>
<li>宏</li>
</ul>


<h3>元编程的可能性与危险性</h3>

<ul>
<li>在程序运行时对程序本身进行操作</li>
<li>灵活性</li>
</ul>


<h2>2.4 内存管理</h2>

<h3>看似无限的内存</h3>

<ul>
<li>垃圾回收机制</li>
<li>虚拟内存</li>
</ul>


<h2>GC的3种基本方式</h2>

<ul>
<li>标记清除方式</li>
<li>复制收集方式</li>
<li>引用计数方式</li>
</ul>


<h3>进一步改良的应用方式</h3>

<ul>
<li>分代回收</li>
<li>增量回收</li>
<li>并行回收</li>
<li>GC大统一理论</li>
</ul>


<h2>2.5 异常处理</h2>

<ul>
<li>凡是可能出错的事总会出错</li>
<li>用特殊值返回错误</li>
<li>容易忽略错误处理</li>
<li>产生异常</li>
<li>更高级的异常处理</li>
<li>Ruby中的后处理保证</li>
<li>其他语言的异常处理</li>
<li>Java的检查型异常</li>
<li>Icon的异常与真假值</li>
<li>Eiffel的Design By Contract (契约式设计)</li>
<li>异常与错误值</li>
</ul>


<h2>2.6 闭包</h2>

<ul>
<li>函数对象</li>
<li>高阶函数</li>
<li>用函数参数提高通用性 (qsort)</li>
<li>函数指针的局限 (函数无法访问到外部局部变量)</li>
<li>作用域：变量可见范围</li>
<li>生存周期：变量的存在范围</li>
<li>闭包与面向对象(过程与数据的结合)</li>
</ul>


<h3>Ruby与JavaScript的区别</h3>

<ul>
<li>Ruby中只有方法没有函数</li>
<li>过程对象(Proc)不是函数，需要调用call方法</li>
</ul>


<h1>3 编程语言的新潮流</h1>

<h2>3.1 语言的设计</h2>

<ul>
<li>服务端和客户端</li>
<li>Java在服务端成功的理由：可移植性，功能强大，高性能，丰富的库</li>
<li>JavaScript在客户端，性能显著提升</li>
<li>服务端的Ruby</li>
<li>服务端的Go</li>
<li>动态类型的立场：数据拥有类型，且只有数据拥有类型</li>
<li>静态类型的立场：数据拥有类型，存放数据的变量，表达式也拥有类型，且类型在编译时就固定了</li>
<li>动态类型的有点：简洁，灵活性高</li>
<li>静态类型的优点：容易发现bug，性能高</li>
<li>结构子类型 (Structural Subtyping)</li>
</ul>


<h2>3.2 Go</h2>

<ul>
<li>新的</li>
<li>实验性的</li>
<li>并发的</li>
<li>带垃圾回收</li>
<li>系统语言</li>
</ul>


<h2>语言</h2>

<ul>
<li>无继承式面向对象</li>
<li>多值与多重赋值</li>
<li>并发编程</li>
</ul>


<h2>3.3 Dart</h2>

<ul>
<li>更现代，更安全，高速的语言</li>
<li>基于类的对象系统</li>
<li>非强制性静态类型</li>
</ul>


<h2>3.4 CoffeeScript</h2>

<ul>
<li>JavaScript：最普及的语言，被误解最多的语言，显著高速化的语言</li>
<li>其他略</li>
</ul>


<h2>3.5 Lua</h2>

<ul>
<li>数据类型</li>
<li>函数</li>
<li>表</li>
<li>元表</li>
<li>方法调用的实现</li>
<li>基于原型编程</li>
<li>嵌入式语言(一个进程可以容纳多个解释器)</li>
<li>嵌入式ruby(mruby)</li>
</ul>


<h1>4 云计算时代的编程</h1>

<h2>4.1 可扩展性</h2>

<ul>
<li>K, M, G, T, P, E, Z, Y</li>
<li>大量数据的查找</li>
<li>二分法查找</li>
<li>散列表（链地址法和开放地址法）</li>
<li>布隆过滤器(概率算法)</li>
<li>分布式散列表</li>
<li>MapReduce</li>
</ul>


<h2>4.2 C10K问题</h2>

<ul>
<li>同时工作的进程不会那么多吧</li>
<li>内存的容量足够用来处理所创建的进程和线程的数量吧</li>
<li>同时打开的文件描述符的数量不会有那么多吧</li>
<li>要对多个文件描述符进行监视，用select系统调用就足够了吧</li>
<li>解决问题：使用epoll，使用libev框架，使用EventMachine等</li>
</ul>


<h2>4.3 HashFold</h2>

<p>代码及分析略。。</p>

<h2>4.4 进程间通信</h2>

<ul>
<li>进程和线程（线程共享内存空间，是否利用多核和实现有关）</li>
<li>进程间通信（管道，消息，信号量，共享内存，TCP，UDP，UNIX域套接字）</li>
<li>UDP的特点（数据以数据包为单位发送，没有纠错机制，不需要连接，高速）</li>
<li>TCP的特点（数据以字节流处理，无法按照包为单位查看）</li>
</ul>


<h2>4.5 Rack与Unicorn</h2>

<ul>
<li>Rack中间件</li>
<li>应用服务器的问题（响应缓慢，内存开销，分配不均衡，重启缓慢，部署缓慢）</li>
<li>Unicorn如何解决这些问题 略</li>
</ul>


<h1>5 支撑大数据的数据存储技术</h1>

<h2>5.1 键 - 值存储</h2>

<ul>
<li>Hash和DBM</li>
<li>ACID：原子性，一致性，隔离性，持久性 (Atomicity, Consistency, Isolation, Durability)</li>
<li>CAP原则：一致性，可用性，分裂容忍性 (Consistency, Availability, Partition Tolerance) 只能同时满足2个。。</li>
<li>BASE原则：可用性，严密性，最终一致性(Basically Available, Soft-state, Eventually consistent)</li>
</ul>


<h2>5.2 NoSQL</h2>

<ul>
<li>No SQL vs Not only SQL</li>
<li>键 - 值 存储数据库，面向文档数据库，面向对象数据库</li>
<li>CouchDB和MongoDB</li>
</ul>


<h2>5.3 用Ruby来操作MongoDB</h2>

<p>略</p>

<h2>5.4 SQL数据库的反击</h2>

<ul>
<li>MySQL的存储引擎Spider，逻辑和数据库相分离，可维护性高</li>
<li>斯通布雷克提出：NoSQL的优势在于性能和灵活性，NoSQL的性能优于SQL这一说法，并非在所有情况下都成立，性能问题于SQL和ACID无关</li>
<li>性能瓶颈：日志，事务锁，内存锁，缓存管理</li>
</ul>


<h2>5.5 memcached和它的伙伴们</h2>

<ul>
<li>用户高速访问的缓存</li>
<li>memcached的不足：数据长度，分布式，持久性</li>
<li>Redis</li>
</ul>


<h1>6 多核时代的编程</h1>

<h2>6.1 摩尔定律</h2>

<ul>
<li>呈几何级数增长</li>
<li>提高性能</li>
<li>摩尔定律的极限</li>
</ul>


<h2>6.2 UNIX管道</h2>

<ul>
<li>阿姆达尔定律</li>
<li>多核编程</li>
</ul>


<h2>6.3 非阻塞I/O</h2>

<p>略。。</p>

<h2>6.4 node.js</h2>

<ul>
<li>事件驱动</li>
</ul>


<h2>ZeroMQ</h2>

<ul>
<li>分布式进程间通信</li>
</ul>


</div>


            <div class="footer">
              <div class="contact">
                <div>lyuehh</div>
                <div>programmer</div>
                <div>lyuehh^gmail.com</div>
              </div>
              <div class="contact">
                <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                <a href="http://weibo.com/lyused/">weibo.com/lyused</a><br />
              </div>
            </div>

            <div class="comments">
              <!-- Duoshuo Comment BEGIN -->
                <div class="ds-thread"></div>
                <script type="text/javascript">
                var duoshuoQuery = {short_name:"lyuehh-blog"};
                (function() {
                  var ds = document.createElement('script');
                  ds.type = 'text/javascript';ds.async = true;
                  ds.src = 'http://static.duoshuo.com/embed.js';
                  ds.charset = 'UTF-8';
                  (document.getElementsByTagName('head')[0]
                  || document.getElementsByTagName('body')[0]).appendChild(ds);
                })();
                </script>
              <!-- Duoshuo Comment END -->
            </div>
          </div>

        </div> <!-- /container -->
    </body>
</html>
