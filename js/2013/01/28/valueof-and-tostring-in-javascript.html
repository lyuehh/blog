<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>JavaScript 中valueOf() 和 toString()的区别"</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/index.html">blog</a></h1>
              <a class="extra" href="/about.html">about</a>
            </div>

            <h2>JavaScript 中valueOf() 和 toString()的区别"</h2>
<p class="meta">2013-01-28 21:24</p>

<div id="post">
<p>下面是问题:</p>

<p><code>javascript
var x = {
  toString: function() { return "foo"; },
  valueOf: function() { return 42; }
};
window.console.log ("x="+x);
window.console.log ("x="+x.toString());
</code>
问控制台会输出什么.</p>

<p>这个肯定不能随便猜,作为编程语言,都是有个规范来参考,对于js来说,
规范就是那个Ecma文档,这里我们参考Ecma-262.pdf.</p>

<p>首先在11.6.1,解释了+号的计算流程,我就照抄过来了:</p>

<blockquote><p>The addition operator either performs string concatenation or numeric addition.<br/>
The production AdditiveExpression : AdditiveExpression + MultiplicativeExpression is evaluated as follows:<br/>
1. Let lref be the result of evaluating AdditiveExpression.<br/>
2. Let lval be GetValue(lref).<br/>
3. Let rref be the result of evaluating MultiplicativeExpression.<br/>
4. Let rval be GetValue(rref).<br/>
5. Let lprim be ToPrimitive(lval).<br/>
6. Let rprim be ToPrimitive(rval).<br/>
7. If Type(lprim) is String or Type(rprim) is String, then<br/>
  a. Return the String that is the result of concatenating ToString(lprim) followed by ToString(rprim)<br/>
8. Return the result of applying the addition operation to ToNumber(lprim) and ToNumber(rprim). See the<br/>
Note below 11.6.3.<br/>
NOTE 1 No hint is provided in the calls to ToPrimitive in steps 5 and 6. All native ECMAScript objects except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the absence of a hint as if the hint String were given. Host objects may handle the absence of a hint in some other manner.<br/>
NOTE 2 Step 7 differs from step 3 of the comparison algorithm for the relational operators (11.8.5), by using the logical-or operation instead of the logical-and operation.</p></blockquote>

<p>简单翻译如下:<br/>
+号操作符会进行字符串拼接操作或2个数字相加<br/>
a = b + c会按照如下步骤进行:<br/>
1 计算b的值,赋给lref<br/>
2 计算GetValue(lref), 赋给lval<br/>
3 计算c的值,赋给rref<br/>
4 计算GetValue(rref), 赋给rval<br/>
5 计算ToPrimitive(lval), 赋给lprim<br/>
6 计算ToPrimitive(rval), 赋给rprim<br/>
7 如果Type(lprim)是个 String或者Type(rprim)是个String<br/>
  那么把ToString(rprim)拼接在ToString(lprim)的后面, 作为结果返回<br/>
8 否则将ToNumber(lprim)和ToNumber(rprim)相加, 参考11.6.3</p>

<p>太坑爹了,一个+号操作还有这么多步骤,而且每一步都有一个新的API...<br/>
那些API这里只简单介绍一下,详细的内容还请参阅规范..</p>

<p>GetValue(a) 目录在8.7.1 <br/>
如果a不是引用,返回a本身,在这里参数都不是引用,所以其他的就不看了..</p>

<p>ToString(a) 目录在9.8<br/>
a是Undefine类型,返回"undefined"
a是Null类型,返回"null"
a是Boolean类型,返回"true"如果参数是true,返回"false"如果参数是false
a是String,返回参数本身
a是Number类型,这个巨复杂,参考9.8.1
a是Object类型,hint设置为String,然后调用ToPrimitive,然后把结果作为参数调用ToString</p>

<p>ToNumber(a) 目录在9.3<br/>
a是Undefine类型,返回NaN
a是Null类型,返回+0
a是Boolean类型,返回1如果参数是true,返回+0如果参数是false
a是Number类型,返回本身
a是Object类型,hint设置为Number,然后调用ToPrimitive,然后把结果作为参数调用ToNumber</p>

<p>Type() 目录在8<br/>
ECMAScript语言的types是Undefined,Null,Boolean,String,Number和Object.<br/>
Type(x) 是"the type of x"的简写,这里的type指向的ECMAScript语言和规范里定义的那些type.<br/>
大概呢,上面说的就是</p>

<p>这个ToPrimitive()方法我们要看一下,目录在9.1:
说的是如果传入类型是Undefined, Null, Boolean, Number, String就
返回本身,如果是Object,
<code>返回Object的default value, 这个default value呢,
是调用object本身的内部方法[[DefaultValue]],传入可选的参数hint, 这个
内部方法[[DefaultValue]]在8.12.8定义.</code></p>

<p>擦,继续看8.12.8..<br/>
8.12.8很长,这里简单说一下,更详细的请自己参考规范..<br/>
调用内部方法[[DefaultValue]],是如果传递过来的hint是String,如果对象的
toString是个方法,那么调用toString方法,如果结果是个类型为primitive的值,
那么返回这个值;否则如果对象的valueOf是个方法,那么调用ValueOf方法,检查
返回值是否是primitive类型的,如果是则返回;否则,抛出TypeError异常.<br/>
如果传递进来的hint是Number,那么步骤和上面的类似,但是优先调用ValueOf方法
而不是toString方法,都要检查返回值是否是primitive类型.<br/>
然后后面又有解释,说如果调用[[DefaultValue]]时没有传递hint,那么它的行为
就和传递的hint是Number时类似,但是当对象是Date类型时除外,在那种情况下
hint是String.<br/>
然后后面又有解释,说native objects只能返回primitive值,如果宿主对象实现它
自己的[[DefaultValue]]方法,那么它必须保证它的[[DefaultValue]]方法也只会返回
primitive值.</p>

<p>那什么是primitive呢..<br/>
在4.2里,有这么一句话,<code>A primitive value is a member of one of the following
build-in types: Undefined, Null, Boolean, Number, and String.</code>
也就是说,除了Object类型的值,其他的值都认为是primitive的值.</p>

<p>看了这么多规范,那可以解答上面的问题了.</p>

<p><code>javascript
var x = {
  toString: function() { return "foo"; },
  valueOf: function() { return 42; }
};
window.console.log ("x="+x);
window.console.log ("x="+x.toString());
</code></p>

<p>"x=" + x</p>

</div>


            <div class="footer">
              <div class="contact">
                <div>lyuehh</div>
                <div>programmer</div>
                <div>lyuehh^gmail.com</div>
              </div>
              <div class="contact">
                <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                <a href="http://weibo.com/lyused/">weibo.com/lyused</a><br />
              </div>
            </div>
          </div>

        </div> <!-- /container -->

    </body>
</html>
